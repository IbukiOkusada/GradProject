//==========================================================
//
// エディターオブジェクト [edit_object.cpp]
// Author : Ibuki Okusada
//
//==========================================================
#include "edit_object.h"
#include "manager.h"
#include "debugproc.h"
#include "edit_arrow.h"
#include "map_obstacle.h"
#include "objectX.h"
#include "input_mouse.h"
#include "input_keyboard.h"

//==========================================================
// コンストラクタ
//==========================================================
CEdit_Obj::CEdit_Obj()
{
	// 値のクリア
	m_pSelect = nullptr;
	m_pArrow = nullptr;
}

//==========================================================
// デストラクタ
//==========================================================
CEdit_Obj::~CEdit_Obj()
{

}

//==========================================================
// 初期化処理
//==========================================================
HRESULT CEdit_Obj::Init(void)
{
	return S_OK;
}

//==========================================================
// 終了処理
//==========================================================
void CEdit_Obj::Uninit(void)
{
	if (m_pArrow != nullptr)
	{
		m_pArrow->Uninit();
		m_pArrow = nullptr;
	}

	CEdit::Uninit();
}

//==========================================================
// 更新処理
//==========================================================
void CEdit_Obj::Update(void)
{
	CDebugProc::GetInstance()->Print(" [ 道配置モード ]\n");
	CMapObstacle* pOld = m_pSelect;

	// 選択
	ClickCheck();

	CDebugProc::GetInstance()->Print("[");

	// 保存
	Save();

	// 選択されていない、もしくは選択した直後
	if (m_pSelect == nullptr || pOld == nullptr) {

		// 生成
		Create();

		CDebugProc::GetInstance()->Print("]\n");
		return;
	}

	// 選択されたものを色変える
	m_pSelect->GetObj()->SetColMulti(D3DXCOLOR(1.0f, 1.0f, 1.0f, 0.5f));

	// 矢印の更新
	if (m_pArrow != nullptr)
	{
		m_pArrow->Update();
	}

	// 移動
	Move();

	// 削除
	Delete();

	CDebugProc::GetInstance()->Print("]\n");
}

//==========================================================
// 選択
//==========================================================
void CEdit_Obj::ClickCheck()
{
	CInputMouse* pMouse = CInputMouse::GetInstance();
	Clist<CMapObstacle*>* pList = CMapObstacle::GetList();

	if (CMapObstacle::GetList() == nullptr) { return; }

	// 入力があれば確認する
	if (!pMouse->GetTrigger(CInputMouse::BUTTON_LBUTTON))
	{
		return;
	}

	// 矢印選択中
	if (m_pArrow != nullptr)
	{
		if (m_pArrow->GetHold() != nullptr)
		{
			return;
		}
	}

	if (m_pSelect != nullptr)
	{
		m_pSelect->GetObj()->SetColMulti(D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f));
	}

	m_pSelect = nullptr;

	for (int i = 0; i < pList->GetNum(); i++)
	{
		CMapObstacle* pObj = pList->Get(i);

		// 衝突した
		if (CursorCollision(pObj))
		{
			m_pSelect = pObj;

			if (m_pArrow == nullptr)
			{
				m_pArrow = CEdit_Arrow::Create(m_pSelect->GetPosition());
			}

			m_pArrow->SetPosition(m_pSelect->GetPosition());

			return;
		}
	}

	// 道が選ばれていない
	if (m_pSelect != nullptr) { return; }

	// 矢印使用中
	if (m_pArrow == nullptr) { return; }

	m_pArrow->Uninit();
	m_pArrow = nullptr;
}

//==========================================================
// 選択したものとの衝突判定
//==========================================================
bool CEdit_Obj::CursorCollision(CMapObstacle* pObj)
{
	// マウス情報
	CInputMouse* pMouse = CInputMouse::GetInstance();
	CInputMouse::SRayInfo info = pMouse->GetRayInfo();

	// 床情報
	D3DXVECTOR3 pos = pObj->GetPosition();
	D3DXVECTOR3 rot = pObj->GetRotation();
	D3DXVECTOR3 vtxmax = pObj->GetObj()->GetVtxMax();
	D3DXVECTOR3 vtxmin = pObj->GetObj()->GetVtxMin();
	D3DXVECTOR3 touchpos = VECTOR3_ZERO;
	D3DXVECTOR3 origin = pMouse->GetRayInfo().origin;
	D3DXVECTOR3 vec = pMouse->GetRayInfo().vec;

	// 使用されていなかったら返す
	if (collision::CollideRayToOBB(&touchpos, origin, vec, pos, rot, vtxmax, vtxmin))
	{
		return true;
	}

	return false;
}

//==========================================================
// 削除
//==========================================================
void CEdit_Obj::Delete()
{
	CDebugProc::GetInstance()->Print(" 道削除 : Delete or BackSpace, ");
	CInputKeyboard* pKey = CInputKeyboard::GetInstance();

	// 入力確認
	if (!pKey->GetTrigger(DIK_DELETE) && !pKey->GetTrigger(DIK_BACKSPACE)) { return; }

	// 再接続
	m_pSelect->Uninit();
	m_pSelect = nullptr;

	// 矢印使用中
	if (m_pArrow == nullptr) { return; }

	m_pArrow->Uninit();
	m_pArrow = nullptr;
}

//==========================================================
// 移動
//==========================================================
void CEdit_Obj::Move()
{
	if (m_pSelect == nullptr) { return; }
	if (m_pArrow == nullptr) { return; }

	D3DXVECTOR3 pos = m_pArrow->GetPosition();	// 座標

	// 選択した道の座標設定
	m_pSelect->SetPosition(pos);
}

//==========================================================
// 保存
//==========================================================
void CEdit_Obj::Save()
{
	//CDebugProc::GetInstance()->Print(" 保存 : F7, ");
	//CInputKeyboard* pKey = CInputKeyboard::GetInstance();

	//// 入力確認
	//if (!pKey->GetTrigger(DIK_F7)) { return; }

	//CMapObstacleManager* pMgr = CMapObstacleManager::GetInstance();
	//// ファイルを開く
	//std::ofstream File(FILENAME, std::ios::binary);
	//if (!File.is_open()) {
	//	return;
	//}

	//std::vector<CMapObstacle::SInfo> savedata;

	//for (int i = 0; i < pMgr->GetList()->GetNum(); i++)
	//{
	//	savedata.push_back(*pMgr->GetList()->Get(i));
	//}

	//savedata.erase(savedata.begin());
	//savedata.pop_back();
	//int size = savedata.size();

	//// ベクトルのサイズをセーブ
	//File.write(reinterpret_cast<const char*>(&size), sizeof(size));

	//// データをバイナリファイルに書き出す
	//File.write(reinterpret_cast<char*>(savedata.data()), size * sizeof(CMapObstacle::SInfo));

	//// ファイルを閉じる
	//File.close();
}

//==========================================================
// 保存
//==========================================================
void CEdit_Obj::Create()
{
	CDebugProc::GetInstance()->Print(" 生成 : マウスホイールクリック, ");
	CInputMouse* pMouse = CInputMouse::GetInstance();

	// 入力確認
	if (!pMouse->GetTrigger(CInputMouse::BUTTON_WHEEL)) { return; }

	D3DXVECTOR3 rayDir = pMouse->GetRayInfo().vec;
	D3DXVECTOR3 rayOrigin = pMouse->GetRayInfo().origin;

	// レイが Y = 0 の平面と平行な場合（方向ベクトルの Y 成分が 0）
	if (fabs(rayDir.y) < 1e-6f) {
		return;  // 交差しない
	}

	// 交差までの距離 t を計算
	float t = -rayOrigin.y / rayDir.y;

	// t が負の場合、レイの逆方向にあるので交差しない
	if (t < 0.0f) {
		return;
	}

	CMapObstacle::SInfo info = CMapObstacle::SInfo();

	// 交点の座標を計算（Y = 0 平面上）
	info.pos.x = rayOrigin.x + t * rayDir.x;
	info.pos.y = 0.0f;  // Y = 0 なので固定
	info.pos.z = rayOrigin.z + t * rayDir.z;
	info.fileidx = 0;
	info.rot = VECTOR3_ZERO;

	CMapObstacle::Create(info);
}
